## 集合进阶

集合分为两个大类：

+ 单列集合Collection：每次添加一个数据
+ 双列集合Map：每次添加一对数据

分类图：

<div style="text-align:center">
    <img src="images\集合类体系结构图.png" alt="集合">
</div>

### 一、单列集合

+ 分类图

  <div style="text-align:center">
      <img src="images\Collection.png" alt="单列集合">
  </div>

  + list：添加的元素是有序、可重复、有索引。有序指存和取的顺序是一样的
  + set：添加的元素是无序、不重复、无索引。无序指存和取得顺序可能是不一样的

#### 1. Collection

+ Collection是单列集合的祖宗**接口**，它的功能是全部单列集合都可以继承使用的

+ 常用方法

  <div style="text-align:center">
      <img src="images\Collection常用方法.png" alt="常用方法">
  </div>

+ 方法演示

  ```java
  // 给list集合中添加元素，返回true，因为它是可重复的
  // 给set集合中添加元素，如果集合中没有该元素，则添加成功返回true；如果集合中该元素已经存在，则添加失败返回false
  public boolean add(E e)
      
  // 因为Collection定义着共性的方法，所以删除时不能使用索引进行删除，只能通过元素删除
  // 删除的元素不存在，则删除失败返回false；
  public boolean remove(E e)
      
  /* contains在底层遍历集合中的每个元素，依赖equals方法判断对象是否一致
  如果集合中为自定义对象，且没有重写equals方法，那么默认使用Object类中的equals方法进行判断，而Object类中的equals方法，依赖地址值进行判断。所以，如果集合中存储的是自定义对象，也想通过该方法来判断是否包含，那么在javabean类中，需要对该方法进行重写*/
  public boolean contains(Object obj)
  ```

+ Collection遍历

  + 迭代器遍历  （在遍历的时候需要删除元素）

    **迭代器不依赖索引**，所以使用迭代器可以遍历没有索引的set集合

    ```java
    // 获取迭代器对象
    Iterator<E> iterator()	// 返回迭代器对象，默认指向当前集合的开始位置（指针）
    
    // 常用方法
    boolean hasNext()	// 判断当前位置是否有元素
    E next()	// 获取当前位置的元素，并将迭代器对象移向下一个位置
    void remove()	// 删除迭代器当前指向的元素
    ```

    ```java
    Collection<String> list = new ArrayList<String>();
    list.add("A");
    list.add("B");
    list.add("C");
    
    //迭代器遍历
    //获取迭代器对象
    Iterator<String> it = list.iterator();
    //使用迭代器进行集合遍历
    while (it.hasNext()){
        // 获取当前元素，并移动指针到下一个位置
        String str = it.next();
        System.out.println(str);
    }
    ```

    note:

    + 如果当前位置没有元素，还要获取，会报NoSuchElementException

    + 迭代器遍历完毕，迭代器指针不会复位

    + 循环中建议只使用一次next方法，防止出现NoSuchElementException错误

    + 迭代器遍历时，不能使用集合的方法进行增加或删除

      但是可以使用迭代器对象的remove方法进行删除

  + 增强for遍历（仅遍历）

    + 增强for的底层就是迭代器，他是为了简化迭代器的代码书写
    + JDK5之后出现，内部原理就是一个Iterator迭代器
    + 所有的单列集合和数组才能使用增强for进行遍历

    ```java
    // 格式
    for (元素的数据类型 变量名 : 数组或者集合){}
    
    // 增强for遍历
    for (String str : list){
        System.out.println(str);
    }
    ```

  + Lambda表达式遍历（仅遍历）

    ```java
    /* 在Iterator接口中定义了forEach()方法，而Collection接口类继承了该方法。我们可以使用该方法对集合进行遍历*/
    default void forEach(Consumer<? super T> action)
    ```

    ```java
    // forEach方法遍历
    list.forEach(new Consumer<String>() {
        @Override
        // 这个函数代表对获取的每个元素进行的操作，都可以写在这个方法里面
        public void accept(String s) {
            System.out.println(s);
        }
    });
    // 使用Lambda表达式进行简化
    list.forEach((String s) -> System.out.println(s));
    ```
#### 2. List集合

+ 特点：

  + 有序：存和取的元素顺序一致
  + 有索引：可以通过索引操作元素
  + 可重复：存储的元素可以重复

+ 方法介绍

  + Collection的方法均被list继承

  + 因为list集合有索引，所以有很多索引操作方法

    <div style="text-align:center">
        <img src="images\list方法.png" alt="常用方法">
    </div>

    ```java
    /* 在List中有两个remove方法 */
    E remove(int index)		//删除指定索引位置的元素
    boolean remove(Object o)		//删除集合中第一次出现的指定元素
        
    List<Integer> list = new ArrayList<Integer>();
    list.add(1);
    list.add(2);
    
    // 调用remove方法进行删除，此时调用的是哪个remove方法呢？
    /* E remove(int index)  因为调用重载的方法时，会优先调用参数类型一致的方法，而此时的实参 1 其类型为int，所以会调用该方法。 如果想调用boolean remove(Object o)方法则要手动装箱，将实参包装为一个对象*/
    list.remove(1);
    ```

+ 遍历方式

  + 迭代器遍历  （遍历时需要删除元素）

  + 列表迭代器遍历  （遍历时需要添加元素）

    ```java
    List<String> list = new ArrayList<String>();
    list.add("AAA");
    list.add("BBB");
    
    // 使用列表迭代器对象进行遍历
    ListIterator<String> iterator = list.listIterator();
    while (iterator.hasNext()) {
        String str = iterator.next();
        // 在列表迭代器对象中，除了remvoe方法外，还有一个add方法
        if (str.equals("BBB")) {
            // iterator.remove();  删除当前元素，不接受参数
            iterator.add("CCC");
        }
        System.out.println(str);
    }
    ```

  + 增强for遍历  （仅遍历）

  + Lambda表达式遍历  （仅遍历）

  + 普通for遍历  （遍历的时候，需要操作索引）

    ```java
    for (int i = 0; i < list.size(); i++) {
        if (i == 0){
            list.set(i, "DDD");
        }
        System.out.println(list.get(i));
    }
    ```

#### 3. 数据结构

（1）栈

 + 特点：先进后出，后进先出


（2）队列

+ 特点：先进先出，后进后出

（3）数组

+ 特点：
  + 查询速度快：使用地址值和索引定位，查询任意数据耗时相同
  + 删除效率低：要将原始数据删除，同时后面的每个数据前移
  + 添加效率低：添加位置后的每个元素先后移，再添加元素
+ 总结：数组是一种查询快，增删慢的模型

（4）链表

+ 特点
  + 链表中的结点都是独立存在的对象，在内存中是不连续的，每个结点包含数据值和前后节点的地址
  + 链表的查询较慢，因为无论查询哪个数据，都需要从头节点开始找
  + 链表的增删较快，因为它只需要修改对应节点存放的的地址值即可

（5）树

+ 常用概念
  + 度：每一个节点的子节点数量
  + 树高：树的总层数
  + 根节点：最顶层的节点

+ 二叉查找树（二叉排序树 或 二叉搜索树）

  + 特点
    + 每一个节点上最多有两个子节点
    + 任意节点左子树上的值都小于当前节点
    + 任意节点右子树上得值都大于当前节点

  + 添加节点

    + 小的存左边、大的存右边、一样的不存
    + 从根节点遍历插入

  + 树遍历

    左右固定，当前节点在哪就是哪种遍历

    + 前序遍历

      从根节点开始，然后按照**当前节点**，**左子节点**，**右子节点**的顺序遍历

    + 中序遍历（**结果为升序排列**）

      从最左边的子节点开始，然后按照**左子节点**、**当前节点**、**右子节点**的顺序遍历

    + 后序遍历

      从最左边的子节点开始，然后按照**左子节点**、**右子节点**、**当前节点**的顺序遍历

    + 层序遍历

      从根节点一层一层的遍历

+  平衡二叉树

  + 特点

    + 满足二叉查找树的要求
    + 任意节点左右子树的高度差不超过1

    这样可以提高查找效率，但是添加节点时可能过于繁琐

+ 红黑树   **增删改查效率都不错**

  + 概念

    + 是一种自平衡的二叉查找树；每一个节点可以是红或者黑；
    + 他不是高度平衡的，其平衡是通过“红黑规则”进行实现的

  + 红黑规则

    1. 每一个节点或是红色的,或者是黑色的
    2. 根节点必须是黑色
    3. 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的
    4. 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况)
    5. 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点

  + 添加节点

    添加节点默认颜色是红色的（效率高，需要调整的次数少）

    <div style="text-align:center">
        <img src="images\红黑树添加节点.png" alt="常用方法">
    </div>

​    

#### 4. List集合的实现类 

#### 4.1 ArrayList

底层原理：

​	ArrayList底层是**数组结构**

> 利用空参构造创建的集合，在底层创建一个默认长度为0的数组；
>
> 添加第一个元素时，底层会创建一个新的长度为10的数组；
>
> 存满时，会扩容1.5倍；
>
> 如果一次添加多个元素，1.5倍还放不下，则新创建的数组长度以实际为准

**添加一个元素时的扩容**

<div style="text-align:center">
    <img src="images\第一次添加数据.png" alt="常用方法">
</div>

**添加多个元素时的扩容**

<div style="text-align:center">
    <img src="images\第11次添加数据.png" alt="常用方法">
</div>

#### 4.2 LinkedList

+ 底层数据结构是**双向链表**，查询慢，增删快，但是如果操作的是首尾元素，速度快

+ 基于此特点，LinkedList提供了很多直接操作首位元素的特有API（了解即可）

  <div style="text-align:center">
      <img src="images\LinkedList特有方法.png" alt="常用方法">
  </div>

  核心步骤如下：

  1. 刚开始创建的时候，底层创建了两个变量：一个记录头结点first，一个记录尾结点last，默认为null
  2. 添加第一个元素时，底层创建一个结点对象，first和last都记录这个结点的地址值
  3. 添加第二个元素时，底层创建一个结点对象，第一个结点会记录第二个结点的地址值，last会记录新结点的地址值

  <div style="text-align:center">
      <img src="images\LinkedList源码分析.png" alt="源码分析">
  </div>

#### 5. 泛型

+ 介绍

  + 泛型是JDK5中引入的新特性，可以在编译阶段约束操作的数据类型，并进行检查

  + 格式：<数据类型>
  + **泛型只支持引用数据类型**

+ 好处

  + 统一了集合中的数据类型
  + 把运行使其的问题提前到了编译时期，避免了强制类型转换可能出现的异常

+ java中的泛型是伪泛型，他只在添加数据的时候进行检查，当添加完成后，在集合中数据还是会被认为是object对象，在获取数据的时候，会根据泛型的类型将数据从object强转为泛型类型。

  <div style="text-align:center">
      <img src="images\泛型.png" alt="源码分析">
  </div>

+ 注意点

  + 泛型中不能写基本数据类型
  + 指定泛型的具体类型后，传递数据时，可以传入**该类类型或其子类类型**（数据具有继承性）
  + 如果不写泛型，类型默认是Object

+ 泛型类

  当一个类中，某个变量的数据类型不确定时，就可以定义带有泛型的类

  + 格式

    ```java
    修饰符 class 类名<类型>{}
    // 创建该类对象时，E就是确定类型 ，其中E不是用来记录数据的，而是记录数据的类型（T、E、K、V均可）
    public class ArrayList<E>{}
    ```

+ 泛型方法

  + 当方法中的形参类型不确定时：
    + 可以使用类名后面定义好的泛型   -->  所有方法都能用
    + 在方法申明上定义自己的泛型   -->  只有本方法才能用

  + 格式

    ```java
    修饰符 <类型> 返回值类型 方法名(类型 变量名){}
    
    public <T> void show(T t)
    ```

+ 泛型接口

  + 格式

    ```java
    修饰符 interface 接口名<类型>{}
    ```

  + 使用方式

    + 实现类给出具体的类型
    + 实现类延续泛型，创建对象的时候再确定具体类型

+ 泛型通配符

  当我们需要接收一个不确定类型的方法时，可以使用上述三种方法

  但是有一些缺陷：他可以接收任意的数据类型

  当我们只希望传递特定范围内的数据类型时，就可以使用泛型通配符

  ```java
  ?		//表示不确定的类型
  ? extends E			//表示可以传递E或者E的所有子类类型
  ? super E			//表示可以传递E或者E的所有父类类型
  ```

  这是因为**泛型不具有继承性**！！！即如果方法的泛型为Animal，那么在传递参数时，只能传递Animal，而不能传递其子类

  <div style="text-align:center">
      <img src="images\泛型没有继承性.png" alt="源码分析">
  </div>
  <div style="text-align:center">
      <img src="images\数据有继承性.png" alt="源码分析">
  </div>
  
+ 使用场景
  + 定义类、方法、接口的时候，如果类型不确定，就可以定义泛型
  + 如果类型不确定，但是能知道是哪个继承体系中的，可以使用泛型通配符



#### 6. Set集合

+ 特点：
  + 无序：存取顺序不一致
  + 元素不重复：可以使用这个特性去重复
  + 无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引获取元素



#### 7. Set实现类

#### 7.1 HashSet

+ 底层原理

  + hashset集合底层采用哈希表存储数据
  + 哈希表是一种对于增删改查数据性能都较好的结构

+ 哈希值

  + 根据hashCode方法算出来的int类型的整数
  + 该方法定义在Object类中，**所有对象都可以调用**，**默认使用地址值进行计算**
  + 一般情况下，会重写hashCode方法，**利用对象内部的属性值计算哈希值**
  + 特点
    + 如果没有重写hashCode，不同对象计算出的哈希值是不同的（因为不同对象的地址值不一样）
    + 如果重写了hashCode，不同对象只要属性值相同，计算出的哈希值就是一样的
    + 在小部分情况下，不同的属性值或者不同的地址值计算出的哈希值也有可能一样（哈希碰撞）

+ 添加数据原理

  + 在JDK8之前，HashSet是由**数组 + 链表**组成

  + 在JDK8之后，HashSet是由**数组 + 链表 + 红黑树**组成

    当链表长度超过8，而且数组长度大于等于64时，将链表自动转换为红黑树存储

  <div style="text-align:center">
      <img src="images\HashSet.png" alt="源码分析">
  </div>

  其中，如果该位置不为null，则需比较挂在此位置链表中的所有元素，都不一样时，才插入链表！

​	   默认加载因子0.75指，当数组存的元素大于等于16*0.75=12时，数组会扩容为原来的2倍，即32

+ Q?

  + 为什么HashSet存和取的顺序不一样？

    因为，HashSet在遍历的时候，首先从数组的0索引开始，逐个遍历数组中的元素；如果该元素为一个链表或者红黑树，则按着相应的规则读取完；然后接着访问数组中的下一个元素。而HashSet在存的时候他的位置是根据哈希值计算的得出的，导致存放的位置没有规律。

  + HashSet为什么没有索引？

    因为，在HashSet中除了数组外，还有链表和红黑树，那么该选择谁作为索引呢？

  + HashSet是利用什么机制保证去重的？

    hashcode + equals比较

#### 7.2 LinkedHashSet（HashSet的子类）

+ 特点

  **有序**、不重复、无索引

+ 原理

  底层的数据结构依然是哈希表，只是每个元素又额外多了一个**双链表的机制记录存储的顺序**

  <div style="text-align:center">
      <img src="images\LinkedHashSet.png" alt="源码分析">
  </div>

  在上图中，8位置为第一个添加到元素记为双向链表的头节点，然后使用hashcode + equals来存放元素，不同的是，此时每个元素内部会记录上一次添加的元素位置和下一次添加元素的位置，来形成双向链表。在遍历的时候，会使用双向链表从头节点开始访问，保证了存和取得顺序一致

#### 7.3 TreeSet

+ 特点

  + 不重复、无索引、**可排序**（按照元素的**默认规则**，从小到大排序）

    这个可排序，指在遍历TreeSet集合时，他会从小到大遍历

  + 使用**红黑树**的数据结构实现排序，增删改查性能较好

+ 默认规则

  + 对于数值类型，默认按照从小到大的顺序进行排序

  + 对于字符、字符串类型，按照字符在ASCAII码表中的数字升序进行排序

    对于字符串，从第一个字符开始比较逐个比较，一个大就全部大

  + 对于自定义对象

    + 在该JavaBean中实现Comparable接口，重写里面的抽象方法，指定比较规则

      ```java
      public class Student implements Comparable<Student>{
          private String name;
          private int age;
          @Override
          // this指当前添加的对象；o指已经存在红黑树的对象
          public int compareTo(Student o) {
              //按照对象的年龄进行排序
              //主要判断条件: 按照年龄从小到大排序
              int result = this.age - o.age;
              //次要判断条件: 年龄相同时，按照姓名的字母顺序排序
              result = result == 0 ? this.name.compareTo(o.getName()) : result;
              return result;
          }
      }
      ```

    + 创建TreeSet对象的时候，传递比较器Comparator指定规则

      ```java
      public class MyTreeSet4 {
          public static void main(String[] args) {
            	//创建集合对象
              TreeSet<Teacher> ts = new TreeSet<>(new Comparator<Teacher>() {
                  @Override
                  public int compare(Teacher o1, Teacher o2) {
                      //o1表示现在要存入的那个元素
                      //o2表示已经存入到集合中的元素
                    
                      //主要条件
                      int result = o1.getAge() - o2.getAge();
                      //次要条件
                      result = result == 0 ? o1.getName().compareTo(o2.getName()) : result;
                      return result;
                  }
              });
      		//创建老师对象
              Teacher t1 = new Teacher("zhangsan",23);
              Teacher t2 = new Teacher("lisi",22);
              Teacher t3 = new Teacher("wangwu",24);
              Teacher t4 = new Teacher("zhaoliu",24);
      		//把老师添加到集合
              ts.add(t1);
              ts.add(t2);
              ts.add(t3);
              ts.add(t4);
      		//遍历集合
              for (Teacher teacher : ts) {
                  System.out.println(teacher);
              }
          }
      }
      ```

+ 两种比较方式小结
  + 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序
  + 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序
  + 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序
+ 两种方式中关于返回值的规则
  + 如果返回值为负数，表示当前存入的元素是较小值，存左边
  
  + 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存

  + 如果返回值为正数，表示当前存入的元素是较大值，存右边

**使用总结**

<div style="text-align:center">
    <img src="images\单列使用总结.png" alt="源码分析">
</div>

​    

  

### 二、双列集合

+ 双列集合相对于单列集合可以一次添加一对数据，该对数据称为一个**键值对**；其中键不可以重复，值可以重复；他们一一对应，键对应自己的值。
+ 一个”键值对”在Java中称为Entry对象

#### 1. Map（双列集合顶层接口）

+ 常见API

  <div style="text-align:center">
      <img src="images\Map-API.png" alt="源码分析">
  </div>

  ```java
  /* 使用put方法添加元素时：
  1. 如果添加的键不存在时，直接将键值对添加到集合中，返回null
  2. 如果添加的键存在时，那么会把原有的键值对对象覆盖，并将被覆盖的值返回*/
  ```

+ 遍历方式

  + 键找值

    ```java
    // 创建Map集合
    Map<String, String> map = new HashMap<>();
    
    // 添加元素
    map.put("1", "aaa");
    map.put("2", "bbb");
    map.put("3", "ccc");
    
    // 使用键找值进行遍历
    // 获取所有的键，将其放在一个单列集合中
    Set<String> keySet = map.keySet();
    // 遍历这个单列集合，获取每个键
    for (String key : keySet) {
        // 利用键，得到相应的值
        String value = map.get(key);
        System.out.println(key + ":" + value);
    }
    
    // 使用迭代器遍历
    Iterator<String> it = keySet.iterator();
    while (it.hasNext()) {
        String key = it.next();
        String value = map.get(key);
        System.out.println(key + ":" + value);
    }
    
    // 使用lambda表达式遍历
    keySet.forEach(new Consumer<String>() {
        @Override
        public void accept(String s) {
            String value = map.get(s);
            System.out.println(s + ":" + value);
        }
    });
    ```

  + 键值对遍历

    ```java
    // 通过键值对对象进行遍历
    
    // 通过entrySet方法获取所有的键值对对象，返回一个set集合
    Set<Map.Entry<String, String>> entrySet = map.entrySet();
    
    // 使用增强for遍历set，得到每一个键值对对象
    for (Map.Entry<String, String> entry : entrySet) {
        String key = entry.getKey();    // 得到该键值对对象的键
        String value = entry.getValue();    // 得到该键值对对象的值
        System.out.println(key + ":" + value);
    }
    
    // 使用迭代器遍历set，得到每一个键值对对象
    Iterator<Map.Entry<String, String>> it = entrySet.iterator();
    while (it.hasNext()){
        Map.Entry<String, String> entry = it.next();    // 获得当前键值对对象
        String key = entry.getKey();
        String value = entry.getValue();
        System.out.println(key + ":" + value);
    }
    
    // 使用lambda表达式遍历set
    entrySet.forEach(new Consumer<Map.Entry<String, String>>(){
        @Override
        public void accept(Map.Entry<String, String> stringStringEntry) {
            String key = stringStringEntry.getKey();
            String value = stringStringEntry.getValue();
            System.out.println(key + ":" + value);
        }
    });
    ```

  + Lambda遍历

    ```java
    // 底层调用forEeach方法进行遍历
    map.forEach(new BiConsumer<String, String>(){
        @Override
        public void accept(String key, String value) {
            System.out.println(key + ":" + value);
        }
    });
    ```

    

#### 2. HashMap

+ 特点
  + HashMap是Map的一个实现类
  + 其特点由键决定：无序、不重复、无索引
  + 其底层原理与HashSet一样，都是哈希表结构
+ 原理
  + 创建一个长度为16，因子为0.75的数组
  + 使用put添加一对键和值（一个entry对象）
  + 使用entry对象的**键**调用hashcode方法计算存放在数组中的位置
  + 如果该位置为空，则直接存放
  + 如果该位置不为空，则使用equals方法比较键是否相同。如果不同则挂在该元素下面，形成一个链表或红黑树结构；如果相同，**则覆盖掉该元素（put方法覆盖的原理）**
+ 总结
  + 依赖hashcode和equals方法保证键的唯一性
  + 如果**键**存储的是自定义对象，需要重写hashcode和equals方法；如果**值**存储的自定义对象，不需要重写hashcode和equals方法，因为存的时候只使用键判断

#### 2. 1 LinkedHashMap（HashMap的子类）

+  特点
  + 由键决定：**有序**、不重复、无索引
  + 原理：底层数据结构依然是哈希表，只是每个键值对元素有额外多了一个双链表机制记录存取的顺序

#### 3. TreeMap

+ 特点：

  + TreeMap与TreeSet底层原理一样，都是红黑树结构
  + 由键决定特性：不重复、无索引、**可排序**
  + 可排序：对**键**进行排序
  + note：默认按照键的从小到大进行排序，也可以按照自己规定的排序规则

+ 排序规则

  + 在javabean类中，实现Comparable接口，指定比较规则（适用于键对象为自定义对象）
  + 在创建集合时传递Comparator对象，指定比较规则（适用于键对象为Integer这种对象，因为你不可能去源代码中去修改吧）
  + 如果同时实现上述两种方式时，第二种的优先级高于第一种

#### 4. Map底层原理

#### 4.1 HashMap

https://www.bilibili.com/video/BV1yW4y1Y7Ms?p=15&spm_id_from=pageDriver&vd_source=fcf175071a45b4f559a3acf9efe00a48



#### 4.2 TreeMap

https://www.bilibili.com/video/BV1yW4y1Y7Ms?p=18&vd_source=fcf175071a45b4f559a3acf9efe00a48

  



#### 5. Else

#### 5.1 可变参数

+ 概念

  JDK5开始出现，他可以使得方法得形参个数可以不是确定的

  ```java
  格式：属性类型...名字   int...args
  ```

+ 原理

  可变参数底层就是一个数组，不过这个不需要我们自己创建，java会帮助我们创建好

+ 演示

  ```java
  // 接收任意整数，求和并返回结果
  public int getSum(int...args){
      int sum = 0;
      // 使用增强for遍历数组args
      for(int i : args){
          sum += i;
      }
      return sum;
  }
  ```

+ note

  + 在方法的形参中最多只能写一个可变参数
  + 在方法的形参中，如果除了可变参数之外，还有其他参数，那么可变参数要写在最后

#### 5.2 Collections

+ 概念

  + java.util.Collections，他是集合工具类

+ 常用API

  <div style="text-align:center">
      <img src="images\Collections-API.png" alt="源码分析">
  </div>



### 不可变集合

+ 即该集合中的数据只能被访问，不能被修改

+ 格式

  在List、Map、Set接口中，都存在静态的of方法，可以获取一个不可变的集合。

  ```java
  static <E> List<E> of()
  static <E> Set<E> of()
  static <K, V> Map<K, V> of()
      
  List<String> list = List.of("张三", "李四", "王五", "赵六");
  Set<String> set = Set.of("张三", "张三", "李四", "王五", "赵六");
  // 参数有上限--20个--10个键值对
  Map<String, String> map = Map.of("张三", "南京", "李四", "北京", "王五", "上海",
                  "赵六", "广州", "孙七", "深圳", "周八", "杭州",
                  "吴九", "宁波", "郑十", "苏州", "刘一", "无锡",
                  "陈二", "嘉兴");
  // 当键值对的数量超过10个
  //获取到所有的键值对对象（Entry对象）
  Set<Map.Entry<String, String>> entries = hm.entrySet();
  //把entries变成一个数组
  Map.Entry[] arr1 = new Map.Entry[0];
  //toArray方法在底层会比较集合的长度跟数组的长度两者的大小
  //如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组
  //如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用
  Map.Entry[] arr2 = entries.toArray(arr1);
  //不可变的map集合
  Map map = Map.ofEntries(arr2);
  
  // Or
  Map<String, String> map = Map.copyOf(hm);		// JDK10
  ```

  

#### Stream流

+ 作用：结合了Lambda表达式，简化集合、数组的操作

+ 使用步骤

  + 先得到一条Stream流，并把数据放上去

    - Collection体系集合

      使用默认方法stream()生成流， default Stream<E> stream()

    - Map体系集合

      把Map转成Set集合，间接的生成流（keySet or entrySet）

    - 数组

      通过Arrays工具类中的静态方法stream生成流

    - 同种数据类型的多个数据

      通过Stream接口的静态方法of(T... values)生成流

    - note

      of(T... values)中的形参就是一个数组，那么在对数据获取stream流时可以使用第四种方法吗？  NO！ 因为该方法在处理基本数据类型的数组时，会将该数组看作一个整体放入流中，而不是将数组中的每个元素放入流中！

  + 中间方法

    + 流水线上的操作，一次操作完成后，还可以继续进行其他操作

    + 方法介绍

      <div style="text-align:center">
          <img src="images\Stream中间流方法.png" alt="源码分析">
      </div>

        ```java
        ArrayList<String> list = new ArrayList<>();
        list.add("张三丰");
        list.add("张无忌");
        list.add("张翠山");
        list.add("王二麻子");
        list.add("张良");
        
        //filter方法获取流中的 每一个数据.
        //而test方法中的s,就依次表示流中的每一个数据.
        //我们只要在test方法中对s进行判断就可以了.
        //如果判断的结果为true,则当前的数据留下
        //如果判断的结果为false,则当前数据就不要.
        //        list.stream().filter(
        //                new Predicate<String>() {
        //                    @Override
        //                    public boolean test(String s) {
        //                        boolean result = s.startsWith("张");
        //                        return result;
        //                    }
        //                }
        //        ).forEach(s-> System.out.println(s));
        
        //因为Predicate接口中只有一个抽象方法test
        //所以我们可以使用lambda表达式来简化
        //        list.stream().filter(
        //                (String s)->{
        //                    boolean result = s.startsWith("张");
        //                        return result;
        //                }
        //        ).forEach(s-> System.out.println(s));
        
        list.stream().filter(s ->s.startsWith("张")).forEach(s-> System.out.println(s));
        ```

      

  + 终结方法

    + 流水线上的最后一个操作，一个Stream流只能有一个终结方法

      <div style="text-align:center">
          <img src="images\Stream终结流方法.png" alt="源码分析">
      </div>

      ```java
      // 收集到数组中
      ArrayList<String> list = new ArrayList<>();
      list.add("a");
      list.add("b");
      list.add("c");
      
      String[] arr = list.stream().toArray(new IntFunction<String []>() {
          @Override
          public String[] apply(int value) {
              return new String[value];
          }
      });
      
      String[] arr2 = list.stream().toArray(value -> new String[value]);
      ```

      ```java
      // 收集到集合中
      ArrayList<String> list = new ArrayList<String>();
      Collections.addAll(list,"张无忌-男-15", "周芷若-女-14", "赵敏-女-13", "张强-男-20","张三丰-男-100","张零山-男-40", "张良-男-35", "王二麻子-男-37", "谢广坤-男-41");
      
      public static void collectionToList(ArrayList<String> list){
          // 将所有的男性收集到一个List集合中
          List<String> newList =  list.stream().filter(s -> s.split("-")[1].equals("男")).
              collect(Collectors.toList());
          System.out.println(newList);
      }
      
      public static void collectionToSet(ArrayList<String> list){
          // 建议使用确定的变量来调用方法，防止空指针异常
          // 使用toSet来收集，可以自动剔除重复的数据
          Set<String> newSet = list.stream().filter(s -> "男".equals(s.split("-")[1])).
              collect(Collectors.toSet());
          System.out.println(newSet);
      }
      
      public static void collectionToMap(ArrayList<String> list){
          // 将所有男生收集到Map集合中，姓名为键，年龄为值
          Map<String, Integer> map = list.stream().filter(s -> "男".equals(s.split("-")[1])).
              /*
                      *  需要指定两个参数：键生成的规则、值生成的规则
                      *  参数一：
                      *       Function泛型一：表示流中每一个数据的类型
                      *               泛型二：表示Map集合中键的数据类型
                      *        方法apply形参：表示流中每一个数据
                      *               方法体：生成键的代码
                      *               返回值：已经生成的键
                      *   参数二：
                      *       Function泛型一：表示流中每一个数据的类型
                      *               泛型二：表示Map集合中值的数据类型
                      *        方法apply形参：表示流中每一个数据
                      *               方法体：生成值的代码
                      *               返回值：已经生成的值
                      *
                      * */
              collect(Collectors.toMap(new Function<String, String>() {
                  @Override
                  public String apply(String s) {
                      return s.split("-")[0];
                  }
              } ,
      
                                       new Function<String, Integer>() {
                                           @Override
                                           public Integer apply(String s) {
                                               return Integer.parseInt(s.split("-")[2]);
                                           }
                                       }));
      
          Map<String, Integer> newMap = list.stream().filter(s -> "男".equals(s.split("-")[1])).
              collect(Collectors.toMap(s -> s.split("-")[0], s -> Integer.parseInt(s.split("-")[2])));
      
          System.out.println(newMap);
      }
      ```

      





























